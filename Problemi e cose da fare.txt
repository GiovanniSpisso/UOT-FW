Problemi da risolvere e cose da fare

1. Sistemo stampa risultati (es. 10% iterazioni)
   Faccio un po di plot vari sul codice unidimensionale
   esperimenti variando parametri: p, n, R

2. Confronti con Sejourne:
    Confronto con codice nel loro paper (fig3): vedere quale è il loro primale
    controlla come mai il loro duale partendo dal nostro punto poi peggiora invece di migliorare.
    ATTENZIONE: sarebbe meglio runnare il loro codice con homogeneous ma fa peggio, capire come mai.
    

3. Confronti / applicazioni:
    Test su cui balanced fallisce e serve UOT
    Verifico che UOT è robusto rispetto agli outliers
    Esperimenti "pratici" con grande numero variabili solo per FW ottimizzato
    Altre applicazioni? Altri esperimenti e plot? 
    runno x esperimenti e comparo medie dei risultati (attento a come farlo: Wilcoxon?)



# PARAMETRI PLOTS
# cost_vs_time_p2(n1000_p2_delta0.001_eps0.001_iter1000)
np.random.seed(0)
n = 1000 
mu = np.random.randint(0, 101, size = n)
nu = np.random.randint(0, 101, size = n)
c = np.abs(np.subtract.outer(np.arange(n), np.arange(n))) 
p = 2                                                     
M = n * (np.sum(mu) + np.sum(nu))                         
max_iter = 1000                          
delta = 0.001                                             
eps = 0.001                                               

# cost_vs_time_p2(n2000_p2_delta0.1_eps0.001_iter1000)
np.random.seed(0)
n = 2000 
mu = np.random.randint(0, 501, size = n)
nu = np.random.randint(0, 501, size = n)
c = np.abs(np.subtract.outer(np.arange(n), np.arange(n))) 
p = 2                                                     
M = n * (np.sum(mu) + np.sum(nu))                         
max_iter = 1000                          
delta = 0.1                                             
eps = 0.001  


np.random.seed(0)
n = 1000
mu = np.random.randint(1, 2001, size = n)
nu = np.random.randint(1, 2001, size = n)
c = np.abs(np.subtract.outer(np.arange(n), np.arange(n))) 
p = 1.5                                           
M = 2 * (np.sum(mu) + np.sum(nu))                
max_iter = 1000
delta = 0.001                                             
eps = 0.001                                               